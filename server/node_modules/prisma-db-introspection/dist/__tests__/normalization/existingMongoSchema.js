"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var prisma_datamodel_1 = require("prisma-datamodel");
var defaultNormalizer_1 = require("../../common/normalization/defaultNormalizer");
function testWithExisting(schemaFromDb, existingSchema, expectedResultSchema) {
    var parser = prisma_datamodel_1.DefaultParser.create(prisma_datamodel_1.DatabaseType.mongo);
    var fromDb = parser.parseFromSchemaString(schemaFromDb);
    var existing = parser.parseFromSchemaString(existingSchema);
    defaultNormalizer_1.default.create(prisma_datamodel_1.DatabaseType.mongo, existing).normalize(fromDb);
    var renderer = prisma_datamodel_1.DefaultRenderer.create(prisma_datamodel_1.DatabaseType.mongo);
    var resultSchema = renderer.render(fromDb);
    expect(resultSchema).toEqual(expectedResultSchema);
}
describe('Schema normalization from existing mongo schema', function () {
    it('Should copy names and directives from an existing schema.', function () {
        var schemaFromDb = "\n      type useru {\n        age: Int!\n        name: String!\n        birthdaydate: Date!\n        posts: [post]\n        signUpDate: Date!\n      }\n\n      type post @embedded {\n        text: String!\n        likes: Int!\n      }";
        // User has renamed a few types, but post is missing
        var existingSchema = "\n      type User @db(name: \"useru\") {\n        age: Int!\n        name: String!\n        birthday: Date! @db(name: \"birthdaydate\")\n        signedUp: Date! @db(name: \"signUpDate\") @createdAt\n      }";
        // The expected result schema
        var expectedResultSchema = prisma_datamodel_1.dedent("\n      type User @db(name: \"useru\") {\n        age: Int!\n        name: String!\n        birthday: Date! @db(name: \"birthdaydate\")\n        signedUp: Date! @createdAt @db(name: \"signUpDate\")\n        posts: [UserPost]\n      }\n\n      type UserPost @embedded {\n        likes: Int!\n        text: String!\n      }");
        testWithExisting(schemaFromDb, existingSchema, expectedResultSchema);
    });
    it('Should identify ID field correctly.', function () {
        var schemaFromDb = "\n      type useru {\n        _id: String! @id\n        name: String!\n        age: Int!\n      }";
        // User has a renamed ID field
        var existingSchema = "\n      type User @db(name: \"useru\") {\n        email: String! @id\n        name: String!\n      }";
        var expectedResultSchema = prisma_datamodel_1.dedent("\n      type User @db(name: \"useru\") {\n        email: String! @id\n        name: String!\n        age: Int!\n      }");
        testWithExisting(schemaFromDb, existingSchema, expectedResultSchema);
    });
    it('Should respect the ordering from an existing schema.', function () {
        var schemaFromDb = "\n      type User {\n        age: Int!\n        name: String!\n        birthdaydate: Date!\n        posts: [Post]\n        signUpDate: Date!\n      }\n\n      type Post @embedded {\n        text: String!\n        likes: Int!\n        comments: [Comment]\n      }\n      \n      type Comment @embedded {\n        text: String!\n        likes: Int!\n      }\n      \n      type Vehicle {\n        brand: String!\n        wheelCount: Int!\n        horsePower: Float!\n      }\n      ";
        // User has renamed a few types, but post is missing
        var existingSchema = "\n      type Vehicle {\n        wheelCount: Int!\n        brand: String!\n        horsePower: Float!\n      }\n      \n      type User {\n        age: Int!\n        name: String!\n        signUpDate: Date!\n      }";
        // The expected result schema
        var expectedResultSchema = prisma_datamodel_1.dedent("\n      type Vehicle {\n        wheelCount: Int!\n        brand: String!\n        horsePower: Float!\n      }\n      \n      type User {\n        age: Int!\n        name: String!\n        signUpDate: Date!\n        birthdaydate: Date!\n        posts: [UserPost]\n      }\n\n      type UserPost @embedded {\n        comments: [UserPostComment]\n        likes: Int!\n        text: String!\n      }\n      \n      type UserPostComment @embedded {\n        likes: Int!\n        text: String!\n      }");
        testWithExisting(schemaFromDb, existingSchema, expectedResultSchema);
    });
    it('Should remove ambiguous relation names.', function () {
        var schemaFromDb = "\n      type User {\n        email: String! @id\n        posts: [Post] @relation(name: \"PostToUser\")\n      }\n      \n      type Post {\n        likes: Int!\n        text: String!\n        user: User! @relation(name: \"PostToUser\")\n      }";
        var existingSchema = "type User { \n      email: String! @id\n    }";
        var expectedResultSchema = prisma_datamodel_1.dedent("\n      type User {\n        email: String! @id\n        posts: [Post]\n      }\n      \n      type Post {\n        likes: Int!\n        text: String!\n        user: User!\n      }");
        testWithExisting(schemaFromDb, existingSchema, expectedResultSchema);
    });
    it('Should not remove non-ambiguous relation names.', function () {
        var schemaFromDb = "\n      type User {\n        email: String! @id\n        likedPosts: [Post] @relation(name: \"LikedPosts\")\n        posts: [Post] @relation(name: \"PostToUser\")\n      }\n      \n      type Post {\n        likes: Int!\n        likedBy: [User] @relation(name: \"LikedPosts\")\n        user: User! @relation(name: \"PostToUser\")\n      }";
        var existingSchema = "type User { \n        email: String! @id\n      }";
        var expectedResultSchema = prisma_datamodel_1.dedent("\n      type User {\n        email: String! @id\n        likedPosts: [Post] @relation(name: \"LikedPosts\")\n        posts: [Post] @relation(name: \"PostToUser\")\n      }\n      \n      type Post {\n        likedBy: [User] @relation(name: \"LikedPosts\")\n        likes: Int!\n        user: User! @relation(name: \"PostToUser\")\n      }");
        testWithExisting(schemaFromDb, existingSchema, expectedResultSchema);
    });
    it('Should not remove ambiguous relation names when they are explicitely named in the existing schema.', function () {
        var schemaFromDb = "\n      type User {\n        email: String! @id\n        posts: [Post] @relation(name: \"PostToUser\")\n      }\n      \n      type Post {\n        likes: Int!\n        text: String!\n        user: User! @relation(name: \"PostToUser\")\n      }";
        var existingSchema = "type User {\n      posts: [Post] @relation(name: \"PostToUser\")\n    }\n    \n    type Post {\n      user: User! @relation(name: \"PostToUser\")\n    }";
        var expectedResultSchema = prisma_datamodel_1.dedent("\n      type User {\n        email: String! @id\n        posts: [Post] @relation(name: \"PostToUser\")\n      }\n      \n      type Post {\n        user: User! @relation(name: \"PostToUser\")\n        likes: Int!\n        text: String!\n      }");
        testWithExisting(schemaFromDb, existingSchema, expectedResultSchema);
    });
    it('Should remove back relations if they are missing in the reference schema.', function () {
        var schemaFromDb = "\n      type User {\n        email: String! @id\n        posts: [Post]\n      }\n      \n      type Post {\n        likes: Int!\n        text: String!\n        user: User!\n      }";
        var existingSchema = "type User {\n      posts: [Post!]\n    }\n    \n    type Post {\n      likes: Int!\n      text: String!\n    }";
        var expectedResultSchema = prisma_datamodel_1.dedent("\n      type User {\n        email: String! @id\n        posts: [Post]\n      }\n      \n      type Post {\n        likes: Int!\n        text: String!\n      }");
        testWithExisting(schemaFromDb, existingSchema, expectedResultSchema);
    });
});
//# sourceMappingURL=existingMongoSchema.js.map