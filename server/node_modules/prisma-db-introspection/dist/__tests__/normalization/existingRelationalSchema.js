"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var prisma_datamodel_1 = require("prisma-datamodel");
var defaultNormalizer_1 = require("../../common/normalization/defaultNormalizer");
function testWithExisting(schemaFromDb, existingSchema, expectedResultSchema) {
    var parser = prisma_datamodel_1.DefaultParser.create(prisma_datamodel_1.DatabaseType.postgres);
    var fromDb = parser.parseFromSchemaString(schemaFromDb);
    var existing = parser.parseFromSchemaString(existingSchema);
    defaultNormalizer_1.default.create(prisma_datamodel_1.DatabaseType.postgres, existing).normalize(fromDb);
    var renderer = prisma_datamodel_1.DefaultRenderer.create(prisma_datamodel_1.DatabaseType.postgres, true);
    var resultSchema = renderer.render(fromDb);
    expect(resultSchema).toEqual(expectedResultSchema);
}
describe('Schema normalization from existing postgres schema', function () {
    it('Should hide reserved fields when they are not existing in the ref schema.', function () {
        var schemaFromDb = "\n      type User {\n        id: Id! @unique\n        age: Int!\n        name: String!\n        createdAt: DateTime!\n        updatedAt: DateTime!\n      }";
        // User has renamed a few types, but post is missing
        var existingSchema = "type User {\n      id: Id! @unique\n      age: Int!\n      name: String!\n    }";
        // The expected result schema
        var expectedResultSchema = prisma_datamodel_1.dedent("\n    type User {\n      id: Id! @id\n      age: Int!\n      name: String!\n      createdAt: DateTime! @createdAt\n      updatedAt: DateTime! @updatedAt\n    }");
        testWithExisting(schemaFromDb, existingSchema, expectedResultSchema);
    });
    it('Should adjust n:n relations and fall back to 1:n if a 1:n relation is given in the reference datamodel.', function () {
        var schemaFromDb = "\n      type User {\n        id: Id! @unique\n        posts: [Post]\n      }\n      \n      type Post {\n        id: Id! @unique\n        text: String!\n        user: [User]\n      }";
        // User has renamed a few types, but post is missing
        var existingSchema = "\n      type User {\n        id: Id! @unique\n        posts: [Post]\n      }\n      \n      type Post {\n        id: Id! @unique\n        text: String!\n        user: User!\n      }";
        // The expected result schema
        var expectedResultSchema = prisma_datamodel_1.dedent("\n      type User {\n        id: Id! @id\n        posts: [Post]\n      }\n      \n      type Post {\n        id: Id! @id\n        text: String!\n        user: User! @relation(link: TABLE)\n      }");
        testWithExisting(schemaFromDb, existingSchema, expectedResultSchema);
    });
    it('Should adjust n:n relations and fall back to 1:1 if a 1:1 relation is given in the reference datamodel.', function () {
        var schemaFromDb = "\n      type User {\n        id: Id! @unique\n        posts: [Post]\n      }\n      \n      type Post {\n        id: Id! @unique\n        text: String!\n        user: [User]\n      }";
        // User has renamed a few types, but post is missing
        var existingSchema = "\n      type User {\n        id: Id! @unique\n        posts: Post!\n      }\n      \n      type Post {\n        id: Id! @unique\n        text: String!\n        user: User!\n      }";
        // The expected result schema
        var expectedResultSchema = prisma_datamodel_1.dedent("\n      type User {\n        id: Id! @id\n        posts: Post! @relation(link: TABLE)\n      }\n      \n      type Post {\n        id: Id! @id\n        text: String!\n        user: User!\n      }");
        testWithExisting(schemaFromDb, existingSchema, expectedResultSchema);
    });
});
//# sourceMappingURL=existingRelationalSchema.js.map