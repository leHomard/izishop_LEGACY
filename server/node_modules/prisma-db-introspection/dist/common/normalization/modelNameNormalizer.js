"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var pluralize_1 = require("pluralize");
var prisma_datamodel_1 = require("prisma-datamodel");
var normalizer_1 = require("./normalizer");
var ModelNameNormalizer = /** @class */ (function (_super) {
    __extends(ModelNameNormalizer, _super);
    function ModelNameNormalizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ModelNameNormalizer.prototype.normalize = function (model) {
        // We need to sort types according to topological order for name normalization.
        // Otherwise embedded type naming might break as embedded types depend on
        // their parent type.
        this.normalizeTypes(prisma_datamodel_1.toposort(model.types), model);
    };
    ModelNameNormalizer.prototype.assignName = function (obj, newName) {
        if (obj.databaseName === null) {
            // If name was already changed, we don't touch it.
            if (newName !== obj.name) {
                // If name is already conforming to prisma, skip.
                obj.databaseName = obj.name;
                obj.name = newName;
            }
        }
    };
    ModelNameNormalizer.prototype.getNormalizedTypeName = function (name, model) {
        if (name.toUpperCase() === name) {
            return name;
        }
        // Replace all special chars.
        var normalizedName = name.replace(/[^a-z0-9_]+/gi, '');
        normalizedName = prisma_datamodel_1.capitalize(prisma_datamodel_1.camelCase(pluralize_1.singular(normalizedName)));
        // if there is a naming conflict with a known scalar type, use the default name
        if (prisma_datamodel_1.isTypeIdentifier(normalizedName) || prisma_datamodel_1.isTypeIdentifier(pluralize_1.singular(name))) {
            return name;
        }
        // if there is already a table in the database with the exact name we're generating - let's just not do it
        if (model.types.some(function (t) { return t.name === normalizedName; })) {
            return name;
        }
        return normalizedName;
    };
    ModelNameNormalizer.prototype.normalizeType = function (type, model, forceNoRename) {
        if (forceNoRename === void 0) { forceNoRename = false; }
        if (!forceNoRename) {
            this.assignName(type, this.getNormalizedTypeName(type.name, model));
        }
        _super.prototype.normalizeType.call(this, type, model);
    };
    ModelNameNormalizer.prototype.getNormalizedFieldName = function (name, parentType, field) {
        // For all-uppercase field names, we do not normalize.
        if (name.toUpperCase() === name) {
            return name.toLowerCase();
        }
        // Trim _id from related fields.
        if (typeof field.type !== 'string' && name.toLowerCase().endsWith('_id')) {
            name = name.substring(0, name.length - 3);
        }
        // Replace all special chars.
        name = name.replace(/[^a-z0-9_]+/gi, '');
        // Follow prisma conventions.
        var normalizedName = prisma_datamodel_1.camelCase(name);
        // If there is already a field in this type for the normalized name, don't rename.
        var conflictingField = parentType.fields.find(function (f) { return f.name === normalizedName && f !== field; });
        if (conflictingField) {
            return null;
        }
        return normalizedName;
    };
    ModelNameNormalizer.prototype.normalizeField = function (field, parentType, parentModel) {
        // Make field names pretty
        if (!parentType.isEnum && !field.isId) {
            var normalizedName = this.getNormalizedFieldName(field.name, parentType, field);
            if (normalizedName === null) {
                field.comments.push({
                    isError: false,
                    text: 'Field name normalization failed because of a conflicting field name.',
                });
            }
            else {
                this.assignName(field, normalizedName);
            }
        }
        // Make embedded type names pretty
        if (typeof field.type !== 'string' && field.type.isEmbedded) {
            if (!field.type.databaseName)
                field.type.databaseName = field.type.name;
            field.type.name = parentType.name + prisma_datamodel_1.capitalize(pluralize_1.singular(field.name));
        }
    };
    return ModelNameNormalizer;
}(normalizer_1.Normalizer));
exports.default = ModelNameNormalizer;
//# sourceMappingURL=modelNameNormalizer.js.map