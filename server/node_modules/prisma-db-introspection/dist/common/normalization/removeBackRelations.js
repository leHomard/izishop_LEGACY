"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var normalizer_1 = require("./normalizer");
var RemoveBackRelation = /** @class */ (function (_super) {
    __extends(RemoveBackRelation, _super);
    function RemoveBackRelation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RemoveBackRelation.prototype.normalizeType = function (type, parentModel) {
        var _loop_1 = function (i) {
            var field = type.fields[i];
            if (typeof field.type !== 'string' &&
                field.relatedField !== null &&
                this_1.baseType !== null) {
                this_1.baseField =
                    this_1.baseType.fields.find(function (f) { return f.name === field.name; }) || null;
                if (this_1.baseField === null || typeof this_1.baseField.type === 'string')
                    return out_i_1 = i, "continue";
                if (this_1.baseField.type.name !== field.type.name)
                    return out_i_1 = i, "continue";
                // If the reference field has no related field we drop the current field.
                if (this_1.baseField.relatedField === null) {
                    var relatedType = field.type;
                    relatedType.fields = relatedType.fields.filter(function (x) { return x !== field.relatedField; });
                    field.relatedField = null;
                    // Restart search in case we modified our own type.
                    if (relatedType === type) {
                        i = 0;
                    }
                }
            }
            out_i_1 = i;
        };
        var this_1 = this, out_i_1;
        // Here, we explicitely need a classic for loop,
        // as we need to restart it in the case of
        // self-referencing relations. Otherwise
        // we might end up removing too many relations.
        for (var i = 0; i < type.fields.length; i++) {
            _loop_1(i);
            i = out_i_1;
        }
    };
    // This is never called.
    RemoveBackRelation.prototype.normalizeField = function (field, parentType, parentModel) {
        throw new Error('Method not implemented.');
    };
    return RemoveBackRelation;
}(normalizer_1.Normalizer));
exports.RemoveBackRelation = RemoveBackRelation;
//# sourceMappingURL=removeBackRelations.js.map