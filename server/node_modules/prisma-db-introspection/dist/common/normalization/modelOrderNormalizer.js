"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var normalizer_1 = require("./normalizer");
var ModelOrderNormalizer = /** @class */ (function (_super) {
    __extends(ModelOrderNormalizer, _super);
    function ModelOrderNormalizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ModelOrderNormalizer.prototype.normalize = function (model) {
        var _this = this;
        var baseTypes = this.baseModel !== null ? this.baseModel.types : [];
        model.types = model.types.sort(function (a, b) {
            return _this.typeOrderComparer(baseTypes, a, b);
        });
        _super.prototype.normalize.call(this, model);
    };
    ModelOrderNormalizer.prototype.normalizeType = function (type, model) {
        var _this = this;
        // Take base ields into account, otherwise Alphabetically is fallback.
        var baseFields = this.baseType ? this.baseType.fields : [];
        // Zip with index, sort, extract result.
        type.fields = type.fields
            .map(function (field, index) { return [field, index]; })
            .sort(function (a, b) { return _this.fieldOrderComparer(baseFields, a, b); })
            .map(function (tuple) { return tuple[0]; });
    };
    ModelOrderNormalizer.prototype.typeOrderComparer = function (ref, a, b) {
        // Should we also compare for enum?
        var aIndexInRef = ref.findIndex(function (x) { return x.name === a.name || x.databaseName === a.name; });
        var bIndexInRef = ref.findIndex(function (x) { return x.name === b.name || x.databaseName === b.name; });
        // If both types or fields are present in the reference,
        // compare by index. Else, append to back and compare by name.
        if (aIndexInRef === -1 && bIndexInRef === -1) {
            return a.name > b.name ? 1 : -1;
        }
        else if (aIndexInRef === -1) {
            return 1;
        }
        else if (bIndexInRef === -1) {
            return -1;
        }
        else {
            return aIndexInRef > bIndexInRef ? 1 : -1;
        }
    };
    ModelOrderNormalizer.prototype.fieldOrderComparer = function (ref, aTuple, bTuple) {
        var _a = __read(aTuple, 2), a = _a[0], aIndex = _a[1];
        var _b = __read(bTuple, 2), b = _b[0], bIndex = _b[1];
        var aIndexInRef = ref.findIndex(function (x) { return x.name === a.name || x.databaseName === a.name; });
        var bIndexInRef = ref.findIndex(function (x) { return x.name === b.name || x.databaseName === b.name; });
        // If both types or fields are present in the reference,
        // compare by index. Else, append to back and compare by name.
        // Id's always get prepended, even if the ID field is new.
        if (aIndexInRef === -1 && a.isId) {
            return -1;
        }
        else if (bIndexInRef === -1 && b.isId) {
            return 1;
        }
        else if (aIndexInRef === -1 && bIndexInRef === -1) {
            var aName = a.name.toLowerCase();
            var bName = b.name.toLowerCase();
            if (aName === bName) {
                if (a.relatedField !== null && b.relatedField !== null) {
                    // This is to avoid flaky tests. The sort algorithm is
                    // not stable and equality would swap fields back and forth
                    // randomly, which causes trouble with related fields.
                    return a.relatedField.name.toLowerCase() <
                        b.relatedField.name.toLowerCase()
                        ? -1
                        : 1;
                }
                else {
                    // If everything else seems equal,
                    // we utilize the zipped index to force
                    // stable ordering.
                    return aIndex < bIndex ? -1 : 1;
                }
            }
            else {
                return aName < bName ? -1 : 1;
            }
        }
        else if (aIndexInRef === -1) {
            return 1;
        }
        else if (bIndexInRef === -1) {
            return -1;
        }
        else {
            return aIndexInRef < bIndexInRef ? -1 : 1;
        }
    };
    // This is never called.
    ModelOrderNormalizer.prototype.normalizeField = function (field, parentType, parentModel) {
        throw new Error('Method not implemented.');
    };
    return ModelOrderNormalizer;
}(normalizer_1.Normalizer));
exports.default = ModelOrderNormalizer;
//# sourceMappingURL=modelOrderNormalizer.js.map