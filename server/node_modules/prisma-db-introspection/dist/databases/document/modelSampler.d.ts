import { IGQLType } from 'prisma-datamodel';
import { Data } from './data';
import { SamplingStrategy, IDocumentConnector, IDataTypeInferrer } from './documentConnector';
/**
 * Samples all collections in a database and infers all primitive fields and embedded types.
 * Does not infer relations. Fields which might have a relation get their `relationName` attribute
 * set to `ModelSampler.ErrorType` for later resolving.
 */
export declare class ModelSampler<InternalCollectionType> implements ModelSampler<InternalCollectionType> {
    private samplingStrategy;
    static ErrorType: string;
    /**
     * @param samplingStrategy The sampling strategy to use.
     */
    constructor(samplingStrategy?: SamplingStrategy);
    /**
     * Samples all Collections in the given schema.
     * @param connector The connector, delivering the data.
     * @param schemaName The name of the schema to resolve.
     * @param primitiveResolver The resolver used for resolving primitive types.
     */
    sample(connector: IDocumentConnector<InternalCollectionType>, schemaName: string, primitiveResolver: IDataTypeInferrer): Promise<IGQLType[]>;
}
/**
 * Infers structure of a datatype from a set of data samples.
 *
 * Follows a streaming pattern to reduce the memory footprint
 */
export declare class ModelMerger {
    private fields;
    private embeddedTypes;
    name: string;
    isEmbedded: boolean;
    primitiveResolver: IDataTypeInferrer;
    /**
     * @param name Name of the type
     * @param isEmbedded Indicates if the type is an embedded type
     * @param primitiveResolver Resolver or primitive types.
     */
    constructor(name: string, isEmbedded: boolean, primitiveResolver: IDataTypeInferrer);
    /**
     * Analyzes this data sample.
     */
    analyze(data: Data): void;
    /**
     * Gets the top level type only.
     */
    getTopLevelType(): IGQLType;
    /**
     * Gets the type with embedded types attached recursivley.
     */
    getType(): {
        type: IGQLType;
        embedded: IGQLType[];
    };
    /**
     * Takes a list of type candidates and merges them into one single type.
     *
     * TODO: If we get more types to summarize, we should have all summarization code (e.g. for arrays)
     * in one place.
     */
    private summarizeTypeList;
    /**
     * Merges all collected info into a field, including type info, relation info
     * and array properties.
     *
     * Creates error comments on inconsistency.
     */
    private toIGQLField;
    /**
     * Initialization helper for empty field info
     * structures
     * @param name
     */
    private initField;
    /**
     * Analyzes a field with respect to it's value.
     */
    private analyzeField;
    /**
     * Merges two field infos.
     */
    private mergeField;
    private merge;
}
