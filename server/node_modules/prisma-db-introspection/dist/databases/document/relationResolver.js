"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var documentConnector_1 = require("./documentConnector");
var modelSampler_1 = require("./modelSampler");
var debug = require('debug')('relation-resolver');
/**
 * Resolves relations on a given model by querying the database.
 */
var RelationResolver = /** @class */ (function () {
    /**
     * @param samplingStrategy Sampling strategy for picking samples.
     * @param threshold Ratio of hits/(misses + hits) we need to accept.
     */
    function RelationResolver(samplingStrategy, threshold) {
        if (samplingStrategy === void 0) { samplingStrategy = documentConnector_1.SamplingStrategy.Random; }
        if (threshold === void 0) { threshold = 0.5; }
        this.samplingStrategy = samplingStrategy;
        this.ratioThreshold = threshold;
    }
    /**
     * Resolves relations in the given type list.
     * @param types Types to resolve relations for. Can be a subset of all types in the database,
     * we still check all collections. Types are edited in-place.
     * @param connector Database connector for sampling
     * @param schemaName The schema to work on.
     */
    RelationResolver.prototype.resolve = function (types, connector, schemaName) {
        return __awaiter(this, void 0, void 0, function () {
            var e_1, _a, allCollections, _loop_1, this_1, types_1, types_1_1, type, e_1_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, connector.getInternalCollections(schemaName)];
                    case 1:
                        allCollections = _b.sent();
                        _loop_1 = function (type) {
                            var _a, collection, iterator, context, data;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        if (!!type.isEmbedded) return [3 /*break*/, 8];
                                        _a = __read(allCollections.filter(function (x) { return x.name === type.name; }), 1), collection = _a[0];
                                        if (collection === undefined) {
                                            throw new Error("Missmatch between collections and given types: Collection " + type.name + " does not exist.");
                                        }
                                        return [4 /*yield*/, connector.sample(collection.collection, this_1.samplingStrategy)
                                            // Create resolver context
                                        ];
                                    case 1:
                                        iterator = _b.sent();
                                        context = new RelationResolveContext(type, allCollections, connector);
                                        _b.label = 2;
                                    case 2: return [4 /*yield*/, iterator.hasNext()];
                                    case 3:
                                        if (!_b.sent()) return [3 /*break*/, 6];
                                        return [4 /*yield*/, iterator.next()];
                                    case 4:
                                        data = _b.sent();
                                        return [4 /*yield*/, context.attemptResolve(data)];
                                    case 5:
                                        _b.sent();
                                        return [3 /*break*/, 2];
                                    case 6: return [4 /*yield*/, iterator.close()
                                        // Collect results
                                    ];
                                    case 7:
                                        _b.sent();
                                        // Collect results
                                        context.connectRelationsIfResolved(types, this_1.ratioThreshold);
                                        _b.label = 8;
                                    case 8: return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 7, 8, 9]);
                        types_1 = __values(types), types_1_1 = types_1.next();
                        _b.label = 3;
                    case 3:
                        if (!!types_1_1.done) return [3 /*break*/, 6];
                        type = types_1_1.value;
                        return [5 /*yield**/, _loop_1(type)];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5:
                        types_1_1 = types_1.next();
                        return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 9];
                    case 8:
                        try {
                            if (types_1_1 && !types_1_1.done && (_a = types_1.return)) _a.call(types_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    return RelationResolver;
}());
exports.RelationResolver = RelationResolver;
/**
 * Resolver context for resolving relations.
 * Follows a streaming pattern to keep the memory footprint low.
 */
var RelationResolveContext = /** @class */ (function () {
    /**
     * @param type The type which is being resolved.
     * @param collections A list of all existing collections.
     * @param connector A connector, capable of checking wether a certain item exists.
     */
    function RelationResolveContext(type, collections, connector) {
        var e_2, _a, e_3, _b;
        this.type = type;
        this.collections = collections;
        this.connector = connector;
        this.fieldScores = {};
        this.embeddedTypes = {};
        try {
            // Build up hit/miss table for all combinations of field/collection
            for (var _c = __values(type.fields), _d = _c.next(); !_d.done; _d = _c.next()) {
                var field = _d.value;
                // We do not resolve error'd fields
                if (!this.hasError(field)) {
                    if (typeof field.type === 'string') {
                        // Primitive
                        if (field.relationName === modelSampler_1.ModelSampler.ErrorType) {
                            try {
                                for (var _e = __values(this.collections), _f = _e.next(); !_f.done; _f = _e.next()) {
                                    var collection = _f.value;
                                    if (!this.fieldScores[field.name]) {
                                        this.fieldScores[field.name] = {};
                                    }
                                    this.fieldScores[field.name][collection.name] = {
                                        hits: 0,
                                        misses: 0,
                                    };
                                }
                            }
                            catch (e_3_1) { e_3 = { error: e_3_1 }; }
                            finally {
                                try {
                                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                                }
                                finally { if (e_3) throw e_3.error; }
                            }
                        }
                    }
                    else {
                        // Embedded document, handled recursively
                        this.embeddedTypes[field.name] = new RelationResolveContext(field.type, this.collections, this.connector);
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    RelationResolveContext.prototype.hasError = function (obj) {
        return obj.comments.some(function (x) { return x.isError; });
    };
    /**
     * Uses a given document, data, for analysis.
     *
     * For each primitive field of the current type with a potential relation,
     * checks if the corresponding value in data is the id of any collection.
     *
     * If so, increases the hit counter, otherwise, increases the miss counter.
     */
    RelationResolveContext.prototype.attemptResolve = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var e_4, _a, e_5, _b, e_6, _c, e_7, _d, data_1, data_1_1, val, e_4_1, _e, _f, field, value, values, values_1, values_1_1, value_1, _g, _h, collection, e_7_1, e_6_1, e_8, e_5_1;
            return __generator(this, function (_j) {
                switch (_j.label) {
                    case 0:
                        if (!Array.isArray(data)) return [3 /*break*/, 9];
                        _j.label = 1;
                    case 1:
                        _j.trys.push([1, 6, 7, 8]);
                        data_1 = __values(data), data_1_1 = data_1.next();
                        _j.label = 2;
                    case 2:
                        if (!!data_1_1.done) return [3 /*break*/, 5];
                        val = data_1_1.value;
                        return [4 /*yield*/, this.attemptResolve(val)];
                    case 3:
                        _j.sent();
                        _j.label = 4;
                    case 4:
                        data_1_1 = data_1.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_4_1 = _j.sent();
                        e_4 = { error: e_4_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                        return [7 /*endfinally*/];
                    case 8: return [3 /*break*/, 34];
                    case 9:
                        _j.trys.push([9, 32, 33, 34]);
                        _e = __values(this.type.fields), _f = _e.next();
                        _j.label = 10;
                    case 10:
                        if (!!_f.done) return [3 /*break*/, 31];
                        field = _f.value;
                        if (!!this.hasError(field)) return [3 /*break*/, 30];
                        if (!(typeof field.type === 'string')) return [3 /*break*/, 28];
                        if (!(field.relationName === modelSampler_1.ModelSampler.ErrorType)) return [3 /*break*/, 27];
                        _j.label = 11;
                    case 11:
                        _j.trys.push([11, 26, , 27]);
                        if (!(data[field.name] !== undefined)) return [3 /*break*/, 25];
                        value = data[field.name];
                        if (Array.isArray(value) !== field.isList) {
                            throw new Error("Array declaration missmatch: " + this.type.name + "." + field.name + " ");
                        }
                        values = Array.isArray(value) ? value : [value];
                        _j.label = 12;
                    case 12:
                        _j.trys.push([12, 23, 24, 25]);
                        values_1 = __values(values), values_1_1 = values_1.next();
                        _j.label = 13;
                    case 13:
                        if (!!values_1_1.done) return [3 /*break*/, 22];
                        value_1 = values_1_1.value;
                        _j.label = 14;
                    case 14:
                        _j.trys.push([14, 19, 20, 21]);
                        _g = __values(this.collections), _h = _g.next();
                        _j.label = 15;
                    case 15:
                        if (!!_h.done) return [3 /*break*/, 18];
                        collection = _h.value;
                        return [4 /*yield*/, this.connector.exists(collection.collection, value_1)];
                    case 16:
                        if (_j.sent()) {
                            this.fieldScores[field.name][collection.name].hits += 1;
                        }
                        else {
                            this.fieldScores[field.name][collection.name].misses += 1;
                        }
                        _j.label = 17;
                    case 17:
                        _h = _g.next();
                        return [3 /*break*/, 15];
                    case 18: return [3 /*break*/, 21];
                    case 19:
                        e_7_1 = _j.sent();
                        e_7 = { error: e_7_1 };
                        return [3 /*break*/, 21];
                    case 20:
                        try {
                            if (_h && !_h.done && (_d = _g.return)) _d.call(_g);
                        }
                        finally { if (e_7) throw e_7.error; }
                        return [7 /*endfinally*/];
                    case 21:
                        values_1_1 = values_1.next();
                        return [3 /*break*/, 13];
                    case 22: return [3 /*break*/, 25];
                    case 23:
                        e_6_1 = _j.sent();
                        e_6 = { error: e_6_1 };
                        return [3 /*break*/, 25];
                    case 24:
                        try {
                            if (values_1_1 && !values_1_1.done && (_c = values_1.return)) _c.call(values_1);
                        }
                        finally { if (e_6) throw e_6.error; }
                        return [7 /*endfinally*/];
                    case 25: return [3 /*break*/, 27];
                    case 26:
                        e_8 = _j.sent();
                        debug({ data: data }, { fieldName: field.name });
                        debug({ error: e_8.toString() });
                        return [3 /*break*/, 27];
                    case 27: return [3 /*break*/, 30];
                    case 28:
                        if (!(data[field.name] !== undefined)) return [3 /*break*/, 30];
                        return [4 /*yield*/, this.embeddedTypes[field.name].attemptResolve(data[field.name])];
                    case 29:
                        _j.sent();
                        _j.label = 30;
                    case 30:
                        _f = _e.next();
                        return [3 /*break*/, 10];
                    case 31: return [3 /*break*/, 34];
                    case 32:
                        e_5_1 = _j.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 34];
                    case 33:
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_5) throw e_5.error; }
                        return [7 /*endfinally*/];
                    case 34: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Checks all aggregated hits and misses, and if the hit/miss ratio
     * is high enough, adds a relation.
     * @param availableTypes A list of all types in the database.
     * @param threshold The hit/miss ratio threshold.
     */
    RelationResolveContext.prototype.connectRelationsIfResolved = function (availableTypes, threshold) {
        var e_9, _a;
        if (threshold === void 0) { threshold = 0.3; }
        var _loop_2 = function (field) {
            var e_10, _a;
            if (!this_2.hasError(field)) {
                if (typeof field.type === 'string') {
                    if (field.relationName === modelSampler_1.ModelSampler.ErrorType) {
                        // Primitive field
                        var bestRatio = 0;
                        var bestCandidate = null;
                        try {
                            for (var _b = __values(this_2.collections), _c = _b.next(); !_c.done; _c = _b.next()) {
                                var collection = _c.value;
                                var score = this_2.fieldScores[field.name][collection.name];
                                var ratio = score.misses + score.hits === 0
                                    ? 0
                                    : score.hits / (score.misses + score.hits);
                                if (ratio > bestRatio || bestCandidate === null) {
                                    bestRatio = ratio;
                                    bestCandidate = collection;
                                }
                            }
                        }
                        catch (e_10_1) { e_10 = { error: e_10_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                            }
                            finally { if (e_10) throw e_10.error; }
                        }
                        if (bestRatio > threshold && bestCandidate !== null) {
                            var candidateName_1 = bestCandidate.name;
                            var _d = __read(availableTypes.filter(function (x) { return x.name == candidateName_1; }), 1), foreignType = _d[0];
                            if (foreignType === undefined) {
                                throw new Error("Missmatch between collections and given types: Type " + candidateName_1 + " does not exist.");
                            }
                            field.type = foreignType;
                            // Add relation directive
                            var relationDirective = {
                                name: 'relation',
                                arguments_1: {},
                            };
                            // Explicit assignment here is a workaround for a TS/Jest bug.
                            // The object initialization above creates a field called 'arguments_1' for
                            // whatever reason.
                            relationDirective.arguments = {
                                link: 'INLINE',
                            };
                            field.directives.push(relationDirective);
                        }
                        // We always remove the fields <unknown> relation tag.
                        field.relationName = null;
                    }
                }
                else {
                    // Embedded document, recursive
                    this_2.embeddedTypes[field.name].connectRelationsIfResolved(availableTypes, threshold);
                }
            }
        };
        var arguments_1 = arguments, this_2 = this;
        try {
            // Recursive, as above, find maximal candidate, check if is over threshold, connect all.
            for (var _b = __values(this.type.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
                var field = _c.value;
                _loop_2(field);
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_9) throw e_9.error; }
        }
        return this.type;
    };
    return RelationResolveContext;
}());
//# sourceMappingURL=relationResolver.js.map