"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var relationalConnector_1 = require("../relationalConnector");
var pg_1 = require("pg");
var prisma_datamodel_1 = require("prisma-datamodel");
var postgresIntrospectionResult_1 = require("./postgresIntrospectionResult");
var postgresDatabaseClient_1 = require("./postgresDatabaseClient");
var debug = require("debug");
var log = debug('PostgresIntrospection');
// Documentation: https://www.prisma.io/docs/data-model-and-migrations/introspection-mapping-to-existing-db-soi1/
// Responsible for extracting a normalized representation of a PostgreSQL database (schema)
var PostgresConnector = /** @class */ (function (_super) {
    __extends(PostgresConnector, _super);
    function PostgresConnector(client) {
        var _this = this;
        if (client instanceof pg_1.Client) {
            client = new postgresDatabaseClient_1.default(client);
        }
        _this = _super.call(this, client) || this;
        return _this;
    }
    PostgresConnector.prototype.getDatabaseType = function () {
        return prisma_datamodel_1.DatabaseType.postgres;
    };
    PostgresConnector.prototype.createIntrospectionResult = function (models, relations, enums, sequences) {
        log('Creating postgres specific introspection result.');
        return new postgresIntrospectionResult_1.PostgresIntrospectionResult(models, relations, enums, sequences);
    };
    PostgresConnector.prototype.listSchemas = function () {
        return __awaiter(this, void 0, void 0, function () {
            var schemas;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        log('Listing schemas.');
                        return [4 /*yield*/, _super.prototype.listSchemas.call(this)];
                    case 1:
                        schemas = _a.sent();
                        return [2 /*return*/, schemas.filter(function (schema) { return !schema.startsWith('pg_'); })];
                }
            });
        });
    };
    PostgresConnector.prototype.getTypeColumnName = function () {
        return 'udt_name';
    };
    PostgresConnector.prototype.getAutoIncrementCondition = function () {
        return 'false';
    };
    PostgresConnector.prototype.parameter = function (count, type) {
        return "$" + count + "::" + type;
    };
    // TODO: Unit test for column comments
    PostgresConnector.prototype.queryColumnComments = function (schemaName) {
        return __awaiter(this, void 0, void 0, function () {
            var commentQuery, comments;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        log("Querying column comments for " + schemaName);
                        commentQuery = "\n      SELECT\n      (\n        SELECT\n          pg_catalog.col_description(c.oid, cols.ordinal_position::int)\n        FROM pg_catalog.pg_class c\n        WHERE\n          c.oid     = (SELECT ('\"' || cols.table_schema || '\".\"' || cols.table_name || '\"')::regclass::oid) AND\n          c.relname = cols.table_name\n      ) as column_comment, cols.column_name as column_name, cols.table_name as table_name\n      FROM\n        information_schema.columns cols\n      WHERE\n        cols.table_schema  = $1::text\n    ";
                        return [4 /*yield*/, this.query(commentQuery, [schemaName])];
                    case 1:
                        comments = (_a.sent())
                            .filter(function (row) { return row.column_comment != undefined; })
                            .map(function (row) { return ({
                            text: row.column_comment,
                            columnName: row.column_name,
                            tableName: row.table_name,
                        }); });
                        return [2 /*return*/, comments];
                }
            });
        });
    };
    PostgresConnector.prototype.queryIndices = function (schemaName) {
        return __awaiter(this, void 0, void 0, function () {
            var indexQuery;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        log("Querying indices for table " + schemaName + ".");
                        indexQuery = "\n      SELECT\n          tableInfos.relname as table_name,\n          indexInfos.relname as index_name,\n          array_to_string(array_agg(columnInfos.attname), ',') as column_names,\n          rawIndex.indisunique as is_unique,\n          rawIndex.indisprimary as is_primary_key\n      FROM\n          -- pg_class stores infos about tables, indices etc: https://www.postgresql.org/docs/9.3/catalog-pg-class.html\n          pg_class tableInfos,\n          pg_class indexInfos,\n          -- pg_index stores indices: https://www.postgresql.org/docs/9.3/catalog-pg-index.html\n          pg_index rawIndex,\n          -- pg_attribute stores infos about columns: https://www.postgresql.org/docs/9.3/catalog-pg-attribute.html\n          pg_attribute columnInfos,\n          -- pg_namespace stores info about the schema\n          pg_namespace schemaInfo\n      WHERE\n          -- find table info for index\n          tableInfos.oid = rawIndex.indrelid\n          -- find index info\n          AND indexInfos.oid = rawIndex.indexrelid\n          -- find table columns\n          AND columnInfos.attrelid = tableInfos.oid\n          AND columnInfos.attnum = ANY(rawIndex.indkey)\n          -- we only consider oridnary tables\n          AND tableInfos.relkind = 'r'\n          -- we only consider stuff out of one specific schema\n          AND tableInfos.relnamespace = schemaInfo.oid\n          AND schemaInfo.nspname = $1::text\n      GROUP BY\n          tableInfos.relname,\n          indexInfos.relname,\n          rawIndex.indisunique,\n          rawIndex.indisprimary\n    ";
                        return [4 /*yield*/, this.query(indexQuery, [schemaName])];
                    case 1: return [2 /*return*/, (_a.sent()).map(function (row) {
                            return {
                                tableName: row.table_name,
                                name: row.index_name,
                                fields: _this.parseJoinedArray(row.column_names),
                                unique: row.is_unique,
                                isPrimaryKey: row.is_primary_key,
                            };
                        })];
                }
            });
        });
    };
    PostgresConnector.prototype.parseJoinedArray = function (arrayAsString) {
        if (arrayAsString === null || arrayAsString === undefined) {
            return [];
        }
        return arrayAsString.split(',').map(function (x) { return x.trim(); });
    };
    PostgresConnector.prototype.queryEnums = function (schemaName) {
        return __awaiter(this, void 0, void 0, function () {
            var enumQuery;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        log("Querying enums for schema " + schemaName + ".");
                        enumQuery = "\n      SELECT\n        t.typname AS \"enumName\",  \n        array_to_string(array_agg(e.enumlabel), ',') AS \"enumValues\"\n      FROM pg_type t \n        JOIN pg_enum e ON t.oid = e.enumtypid  \n        JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n      WHERE \n          n.nspname = $1::text\n      GROUP BY t.typname";
                        return [4 /*yield*/, this.query(enumQuery, [schemaName])];
                    case 1: return [2 /*return*/, (_a.sent()).map(function (row) {
                            return {
                                name: row.enumName,
                                values: _this.parseJoinedArray(row.enumValues),
                            };
                        })];
                }
            });
        });
    };
    PostgresConnector.prototype.listSequences = function (schemaName) {
        return __awaiter(this, void 0, void 0, function () {
            var sequenceQuery;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        log('Querying sqeuences.');
                        sequenceQuery = "\n    SELECT\n      sequence_name, start_value\n      FROM \n      information_schema.sequences\n      WHERE\n      sequence_schema =  $1::text";
                        return [4 /*yield*/, this.query(sequenceQuery, [schemaName])];
                    case 1: return [2 /*return*/, (_a.sent()).map(function (row) {
                            return {
                                name: row.sequence_name,
                                initialValue: row.start_value,
                                allocationSize: 1,
                            };
                        })];
                }
            });
        });
    };
    PostgresConnector.prototype.getMetadata = function (schemaName) {
        return __awaiter(this, void 0, void 0, function () {
            var schemaSizeQuery, _a, size, count;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        schemaSizeQuery = "\n      SELECT \n        SUM(pg_total_relation_size(quote_ident(schemaname) || '.' || quote_ident(tablename)))::BIGINT as size\n        FROM pg_tables WHERE schemaname = $1::text";
                        return [4 /*yield*/, this.query(schemaSizeQuery, [schemaName])];
                    case 1:
                        _a = __read.apply(void 0, [_b.sent(), 1]), size = _a[0].size;
                        return [4 /*yield*/, _super.prototype.countTables.call(this, schemaName)];
                    case 2:
                        count = _b.sent();
                        return [2 /*return*/, {
                                countOfTables: count,
                                sizeInBytes: size,
                            }];
                }
            });
        });
    };
    return PostgresConnector;
}(relationalConnector_1.RelationalConnector));
exports.PostgresConnector = PostgresConnector;
//# sourceMappingURL=postgresConnector.js.map