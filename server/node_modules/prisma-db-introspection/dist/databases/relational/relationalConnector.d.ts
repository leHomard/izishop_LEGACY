import { IConnector } from '../../common/connector';
import { DatabaseMetadata } from '../../common/introspectionResult';
import { DatabaseType } from 'prisma-datamodel';
import { RelationalIntrospectionResult } from './relationalIntrospectionResult';
import IDatabaseClient from '../IDatabaseClient';
export interface IInternalIndexInfo {
    tableName: string;
    name: string;
    fields: string[];
    unique: boolean;
    isPrimaryKey: boolean;
}
export interface IInternalEnumInfo {
    name: string;
    values: string[];
}
export interface IInternalColumnCommentInfo {
    tableName: string;
    columnName: string;
    text: string;
}
export declare abstract class RelationalConnector implements IConnector {
    protected client: IDatabaseClient;
    constructor(client: IDatabaseClient);
    abstract getMetadata(schemaName: string): Promise<DatabaseMetadata>;
    abstract getDatabaseType(): DatabaseType;
    protected abstract createIntrospectionResult(models: ITable[], relations: ITableRelation[], enums: IEnum[], sequences: ISequenceInfo[]): RelationalIntrospectionResult;
    protected query(query: string, params?: any[]): Promise<any[]>;
    /**
     * Column comments are DB specific
     */
    protected abstract queryColumnComments(schemaName: string): Promise<IInternalColumnCommentInfo[]>;
    /**
     * Indices are DB specific
     */
    protected abstract queryIndices(schemaName: string): Promise<IInternalIndexInfo[]>;
    protected abstract queryEnums(schemaName: string): Promise<IEnum[]>;
    protected abstract listSequences(schemaName: string): Promise<ISequenceInfo[]>;
    introspect(schema: string): Promise<RelationalIntrospectionResult>;
    listEnums(schemaName: string): Promise<IEnum[]>;
    /**
     * All queries below use the standardized information_schema table.
     */
    listSchemas(): Promise<string[]>;
    protected listModels(schemaName: string): Promise<ITable[]>;
    protected countTables(schemaName: string): Promise<any>;
    protected queryTables(schemaName: string): Promise<string[]>;
    /**
     * The name of the type column in information_schema.columns.
     *
     * The standardized DATA_TYPE field sitself is too unspecific.
     */
    protected abstract getTypeColumnName(): any;
    /**
     * A condition on information_schema.columns, which shall
     * return true if the column has auto_increment set,
     * false otherwise.
     *
     * If the database supports sequences, this should simply return false.
     */
    protected abstract getAutoIncrementCondition(): any;
    /**
     * Generates a parameter expression for the given SQL dialect.
     */
    protected abstract parameter(count: number, type: string): any;
    protected queryColumns(schemaName: string): Promise<{
        name: string;
        type: string;
        isList: boolean;
        readOnly: boolean;
        isUnique: boolean;
        isAutoIncrement: any;
        defaultValue: string;
        isNullable: boolean;
        comment: string | null;
        tableName: string;
    }[]>;
    protected listRelations(schemaName: string): Promise<ITableRelation[]>;
}
export interface IEnum {
    name: string;
    values: string[];
}
export interface ITable {
    name: string;
    columns: IColumn[];
    indices: IIndex[];
    primaryKey: IIndex | null;
}
export interface IColumn {
    name: string;
    isUnique: boolean;
    defaultValue: any;
    type: string;
    comment: string | null;
    isNullable: boolean;
    isList: boolean;
    tableName: string;
    /**
     * Indicates an auto_increment column. Only use this if the
     * database DOES NOT support sequences.
     */
    isAutoIncrement: boolean;
}
export interface ISequenceInfo {
    name: string;
    initialValue: number;
    allocationSize: number;
}
export interface ITableRelation {
    sourceTable: string;
    targetTable: string;
    sourceColumn: string;
    targetColumn: string;
}
export interface IIndex {
    name: string;
    fields: string[];
    unique: boolean;
}
