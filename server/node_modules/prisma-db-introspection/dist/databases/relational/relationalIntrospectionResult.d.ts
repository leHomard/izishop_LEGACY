import { IntrospectionResult } from '../../common/introspectionResult';
import { ITable, IColumn, IIndex, ITableRelation, IEnum, ISequenceInfo } from './relationalConnector';
import { ISDL, DatabaseType, Renderer, IGQLField, IGQLType, IIndexInfo } from 'prisma-datamodel';
import { Map } from '../../common/aggregate';
export declare abstract class RelationalIntrospectionResult extends IntrospectionResult {
    protected model: ITable[];
    protected relations: ITableRelation[];
    protected enums: IEnum[];
    protected sequences: ISequenceInfo[];
    constructor(model: ITable[], relations: ITableRelation[], enums: IEnum[], sequences: ISequenceInfo[], databaseType: DatabaseType, renderer?: Renderer);
    /**
     * @deprecated This returns an unnormalized datamodel and might get removed in the near future.
     */
    getDatamodel(): ISDL;
    protected resolveRelations(types: IGQLType[], relations: ITableRelation[]): IGQLType[];
    private getDatabaseName;
    protected normalizeRelatioName(name: string): string;
    protected resolveEnumTypes(types: IGQLType[]): IGQLType[];
    protected abstract resolveSequences(types: IGQLType[], sequences: ISequenceInfo[]): IGQLType[];
    protected resolveRelation(types: Map<IGQLType>, relation: ITableRelation): void;
    protected markNonIdFieldsWithSequencesAsErrored(types: IGQLType[]): IGQLType[];
    protected markMultiIdFieldsForJoinTabesAsErrors(types: IGQLType[]): IGQLType[];
    protected resolveFallbackIdField(types: IGQLType[]): IGQLType[];
    protected hideScalarListTypes(types: IGQLType[]): IGQLType[];
    /**
     * Removes all types which are only there for NM relations
     * @param types
     */
    protected hideJoinTypes(types: IGQLType[]): IGQLType[];
    /**
     * Hides indices on related fields. These are always autmatically created by
     * prisma and dont need to be shown in the datamodel.
     * @param types
     */
    protected hideIndicesOnRelatedFields(types: IGQLType[]): IGQLType[];
    /**
     * Hides unique inidices and marks the corresponding fields as unique instead.
     * @param types
     */
    protected hideUniqueIndices(types: IGQLType[]): IGQLType[];
    protected abstract isTypeReserved(type: IGQLType): boolean;
    protected hideReservedTypes(types: IGQLType[]): IGQLType[];
    protected infer(model: ITable[], enums: IEnum[], relations: ITableRelation[], sequences: ISequenceInfo[]): ISDL;
    protected inferIndex(index: IIndex, fields: IGQLField[]): IIndexInfo;
    protected inferDefaultValues(types: IGQLType[]): IGQLType[];
    protected inferEnumType(model: IEnum): IGQLType;
    protected inferObjectType(model: ITable): IGQLType;
    protected inferField(field: IColumn): IGQLField;
    protected inferFieldTypeAndDefaultValue(field: IGQLField, typeName: string): void;
    /**
     * Maps a native database type. If null is returned, the corresponding
     * field is marked with an error comment.
     * @param typeName
     */
    protected abstract toTypeIdentifyer(fieldTypeName: string, fieldInfo: IGQLField, typeName: string): string | null;
    protected abstract parseDefaultValue(defaultValueString: string, type: string): string | null;
}
