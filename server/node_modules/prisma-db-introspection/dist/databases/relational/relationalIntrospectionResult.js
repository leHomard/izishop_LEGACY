"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var introspectionResult_1 = require("../../common/introspectionResult");
var prisma_datamodel_1 = require("prisma-datamodel");
var aggregate_1 = require("../../common/aggregate");
var debug = require("debug");
var log = debug('RelationalIntrospectionResult');
var RelationalIntrospectionResult = /** @class */ (function (_super) {
    __extends(RelationalIntrospectionResult, _super);
    function RelationalIntrospectionResult(model, relations, enums, sequences, databaseType, renderer) {
        var _this = _super.call(this, databaseType, renderer) || this;
        _this.model = model;
        _this.relations = relations;
        _this.enums = enums;
        _this.sequences = sequences;
        return _this;
    }
    /**
     * @deprecated This returns an unnormalized datamodel and might get removed in the near future.
     */
    RelationalIntrospectionResult.prototype.getDatamodel = function () {
        var dml = this.infer(this.model, this.enums, this.relations, this.sequences);
        log('Inferring done.');
        return dml;
    };
    RelationalIntrospectionResult.prototype.resolveRelations = function (types, relations) {
        var _this = this;
        var e_1, _a;
        var modelsByDbName = aggregate_1.aggregateFlatBy(types, function (t) { return _this.getDatabaseName(t); });
        try {
            for (var relations_1 = __values(relations), relations_1_1 = relations_1.next(); !relations_1_1.done; relations_1_1 = relations_1.next()) {
                var relation = relations_1_1.value;
                this.resolveRelation(modelsByDbName, relation);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (relations_1_1 && !relations_1_1.done && (_a = relations_1.return)) _a.call(relations_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return types;
    };
    RelationalIntrospectionResult.prototype.getDatabaseName = function (obj) {
        if (obj.databaseName !== null) {
            return obj.databaseName;
        }
        else {
            return obj.name;
        }
    };
    RelationalIntrospectionResult.prototype.normalizeRelatioName = function (name) {
        if (name.startsWith('_')) {
            return name.substring(1); // This is most likely a prisma relation name
        }
        else {
            return name;
        }
    };
    RelationalIntrospectionResult.prototype.resolveEnumTypes = function (types) {
        var e_2, _a, e_3, _b, e_4, _c;
        try {
            for (var types_1 = __values(types), types_1_1 = types_1.next(); !types_1_1.done; types_1_1 = types_1.next()) {
                var enumType = types_1_1.value;
                if (!enumType.isEnum)
                    continue;
                try {
                    for (var types_2 = __values(types), types_2_1 = types_2.next(); !types_2_1.done; types_2_1 = types_2.next()) {
                        var type = types_2_1.value;
                        var _loop_1 = function (field) {
                            if (typeof field.type === 'string') {
                                if (field.type === enumType.name) {
                                    // Remove type error hint and set enum type
                                    field.comments = field.comments.filter(function (comment) {
                                        return comment.text !== "Type " + field.type + " is not supported";
                                    });
                                    field.type = enumType;
                                }
                            }
                        };
                        try {
                            for (var _d = __values(type.fields), _e = _d.next(); !_e.done; _e = _d.next()) {
                                var field = _e.value;
                                _loop_1(field);
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (types_2_1 && !types_2_1.done && (_b = types_2.return)) _b.call(types_2);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (types_1_1 && !types_1_1.done && (_a = types_1.return)) _a.call(types_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return types;
    };
    RelationalIntrospectionResult.prototype.resolveRelation = function (types, relation) {
        var e_5, _a, e_6, _b;
        // Correctly sets field types according to given FK constraints.
        var typeA = types[relation.sourceTable];
        var typeB = types[relation.targetTable];
        try {
            for (var _c = __values(typeA.fields), _d = _c.next(); !_d.done; _d = _c.next()) {
                var fieldA = _d.value;
                try {
                    for (var _e = __values(typeB.fields), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var fieldB = _f.value;
                        if (relation.sourceColumn === this.getDatabaseName(fieldA) &&
                            relation.targetColumn === this.getDatabaseName(fieldB)) {
                            if (!fieldB.isId) {
                                fieldA.comments.push({
                                    text: "Relation " + typeA.name + "." + fieldA.name + " -> " + typeB.name + "." + fieldB.name + " does not target the id field of " + typeB.name,
                                    isError: true,
                                });
                            }
                            fieldA.type = typeB;
                            // Add back connecting
                            // TODO: We could look at the data to see if this is 1:1 or 1:n. For now, we use a unique constraint.
                            var connectorFieldAtB = {
                                // This needs to generate a fully normalized name.
                                // Otherwise, the normalization pipeline will attempt to normalize,
                                // which will lead to a @db(name: ...) directive for a collumn that does nfot exist.
                                // Caution: This has to work with the name handling in hideScalarListTypes().
                                // TODO: This should be referring the class NameNormalizer or similar.
                                name: prisma_datamodel_1.lowerCase(prisma_datamodel_1.camelCase(typeA.name)),
                                databaseName: null,
                                defaultValue: null,
                                isList: !fieldA.isUnique,
                                isCreatedAt: false,
                                isUpdatedAt: false,
                                isId: false,
                                idStrategy: null,
                                associatedSequence: null,
                                isReadOnly: false,
                                isRequired: fieldA.isRequired,
                                isUnique: false,
                                relatedField: fieldA,
                                type: typeA,
                                relationName: null,
                                comments: [],
                                directives: [],
                            };
                            // Hook up connector fields
                            fieldA.relatedField = connectorFieldAtB;
                            typeB.fields.push(connectorFieldAtB);
                            return;
                        }
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_5) throw e_5.error; }
        }
        prisma_datamodel_1.GQLAssert.raise("Failed to resolve FK constraint " + relation.sourceTable + "." + relation.sourceColumn + " -> " + relation.targetTable + "." + relation.targetColumn);
    };
    RelationalIntrospectionResult.prototype.markNonIdFieldsWithSequencesAsErrored = function (types) {
        var e_7, _a, e_8, _b;
        try {
            for (var types_3 = __values(types), types_3_1 = types_3.next(); !types_3_1.done; types_3_1 = types_3.next()) {
                var type = types_3_1.value;
                try {
                    for (var _c = __values(type.fields), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var field = _d.value;
                        if (field.idStrategy === prisma_datamodel_1.IdStrategy.Sequence && !field.isId) {
                            field.comments.push({
                                text: 'Only id fields can have sequences',
                                isError: true,
                            });
                        }
                    }
                }
                catch (e_8_1) { e_8 = { error: e_8_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_8) throw e_8.error; }
                }
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (types_3_1 && !types_3_1.done && (_a = types_3.return)) _a.call(types_3);
            }
            finally { if (e_7) throw e_7.error; }
        }
        return types;
    };
    RelationalIntrospectionResult.prototype.markMultiIdFieldsForJoinTabesAsErrors = function (types) {
        var e_9, _a, e_10, _b;
        try {
            for (var types_4 = __values(types), types_4_1 = types_4.next(); !types_4_1.done; types_4_1 = types_4.next()) {
                var type = types_4_1.value;
                if (!type.isRelationTable) {
                    var pkFields = type.fields.filter(function (field) { return field.isId; });
                    if (pkFields.length > 1) {
                        try {
                            for (var pkFields_1 = __values(pkFields), pkFields_1_1 = pkFields_1.next(); !pkFields_1_1.done; pkFields_1_1 = pkFields_1.next()) {
                                var field = pkFields_1_1.value;
                                field.comments.push({
                                    text: "Multiple ID fields (compound indexes) are not supported",
                                    isError: true,
                                });
                            }
                        }
                        catch (e_10_1) { e_10 = { error: e_10_1 }; }
                        finally {
                            try {
                                if (pkFields_1_1 && !pkFields_1_1.done && (_b = pkFields_1.return)) _b.call(pkFields_1);
                            }
                            finally { if (e_10) throw e_10.error; }
                        }
                    }
                }
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (types_4_1 && !types_4_1.done && (_a = types_4.return)) _a.call(types_4);
            }
            finally { if (e_9) throw e_9.error; }
        }
        return types;
    };
    RelationalIntrospectionResult.prototype.resolveFallbackIdField = function (types) {
        var e_11, _a;
        try {
            for (var types_5 = __values(types), types_5_1 = types_5.next(); !types_5_1.done; types_5_1 = types_5.next()) {
                var type = types_5_1.value;
                var idField = type.fields.find(function (x) { return x.isId; });
                if (idField === undefined) {
                    // Okay, we find alternate indices.
                    // First, is there a single field with a sequence or auto increment?
                    var fieldsWithSequences = type.fields.filter(function (field) {
                        return field.idStrategy === prisma_datamodel_1.IdStrategy.Auto ||
                            field.idStrategy === prisma_datamodel_1.IdStrategy.Sequence;
                    });
                    if (fieldsWithSequences.length === 1) {
                        fieldsWithSequences[0].isId = true;
                        continue;
                    }
                    // If not, is there something called id?
                    var idFields = type.fields.filter(function (field) {
                        return field.name === prisma_datamodel_1.LegacyRelationalReservedFields.idFieldName &&
                            field.isUnique;
                    });
                    if (idFields.length === 1) {
                        idFields[0].isId = true;
                        continue;
                    }
                    // If not, is there a single unique field?
                    var uniqueField = type.fields.filter(function (field) { return field.isUnique; });
                    if (uniqueField.length === 1) {
                        uniqueField[0].isId = true;
                        continue;
                    }
                }
            }
        }
        catch (e_11_1) { e_11 = { error: e_11_1 }; }
        finally {
            try {
                if (types_5_1 && !types_5_1.done && (_a = types_5.return)) _a.call(types_5);
            }
            finally { if (e_11) throw e_11.error; }
        }
        return types;
    };
    RelationalIntrospectionResult.prototype.hideScalarListTypes = function (types) {
        var e_12, _a;
        var scalarListTypes = [];
        var _loop_2 = function (type) {
            var e_13, _a;
            try {
                for (var _b = __values(type.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var field = _c.value;
                    if (typeof field.type === 'string')
                        continue;
                    var candidate = field.type;
                    // A type is only a scalar list iff it has
                    // * name of ${type.name}${field.name}
                    // * Has exactly three fields
                    //     * nodeId: typeof type!
                    //     * position: Int!
                    //     * value: ?
                    // TODO: Tim mentioned, but not observed in the wild.
                    // * compound index over nodeId and position
                    if (candidate.fields.length !== 3)
                        continue;
                    if (candidate.name === type.name + "_" + field.name)
                        continue;
                    var _d = __read(candidate.fields.filter(function (field) {
                        return field.name === 'nodeId' &&
                            field.type === type &&
                            field.isRequired == true &&
                            field.isList === false;
                    }), 1), nodeId = _d[0];
                    var _e = __read(candidate.fields.filter(function (field) {
                        return field.name === 'position' &&
                            field.type === prisma_datamodel_1.TypeIdentifiers.integer &&
                            field.isRequired == true &&
                            field.isList === false;
                    }), 1), position = _e[0];
                    var _f = __read(candidate.fields.filter(function (field) {
                        return field.name === 'value' &&
                            field.isRequired == true &&
                            field.isList === false;
                    }), 1), value = _f[0];
                    if (nodeId === undefined ||
                        position === undefined ||
                        value === undefined)
                        continue;
                    // If we got so far, we have found a scalar list type. Hurray!
                    scalarListTypes.push(candidate);
                    // Update the field to show a scalar list
                    field.type = value.type;
                    field.isList = true;
                    // Update the name, if it follows prisma conventions
                    // e.g. userScalarIntList => scalarIntList
                    // This has to work with the backwards field generation in resolveRelation.
                    if (field.name.startsWith("" + prisma_datamodel_1.lowerCase(type.name))) {
                        field.name = prisma_datamodel_1.lowerCase(field.name.substring(type.name.length));
                    }
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_13) throw e_13.error; }
            }
        };
        try {
            for (var types_6 = __values(types), types_6_1 = types_6.next(); !types_6_1.done; types_6_1 = types_6.next()) {
                var type = types_6_1.value;
                _loop_2(type);
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (types_6_1 && !types_6_1.done && (_a = types_6.return)) _a.call(types_6);
            }
            finally { if (e_12) throw e_12.error; }
        }
        // Filter out scalar list types
        return types.filter(function (type) { return !scalarListTypes.includes(type); });
    };
    /**
     * Removes all types which are only there for NM relations
     * @param types
     */
    RelationalIntrospectionResult.prototype.hideJoinTypes = function (types) {
        var e_14, _a;
        var nonJoinTypes = [];
        var _loop_3 = function (type) {
            var relationFields = type.fields.filter(function (field) { return typeof field.type !== 'string'; });
            var relationAndIdFields = type.fields.filter(function (field) { return typeof field.type !== 'string' || field.isId; });
            // A join type only as two relation fields. And sometimes a primary key.
            var isJoinType = (relationFields.length === 2 && type.fields.length === 2) ||
                (relationAndIdFields.length === 3 && type.fields.length === 3);
            if (isJoinType) {
                // We drop the join type, but add a n:m relation to
                // the two related tables.
                var _a = __read(relationFields, 2), relA = _a[0], relB = _a[1];
                // Type checking was done above
                var typeA = relA.type;
                var typeB = relB.type;
                if ((relA.name === 'A' && relB.name === 'B') ||
                    (relB.name === 'A' && relA.name === 'B')) {
                    // In this case, this is a prisma link table. Hide it.
                    if (true || typeA !== typeB) {
                        // Regular case. Two different types via join type.
                        var relatedFieldForA = {
                            name: typeB.name,
                            type: typeB,
                            isList: true,
                            isUnique: false,
                            isId: false,
                            idStrategy: null,
                            associatedSequence: null,
                            isCreatedAt: false,
                            isUpdatedAt: false,
                            isRequired: true,
                            isReadOnly: false,
                            comments: [],
                            directives: [],
                            defaultValue: null,
                            relatedField: null,
                            databaseName: null,
                            relationName: this_1.normalizeRelatioName(type.name),
                        };
                        var relatedFieldForB = {
                            name: typeA.name,
                            type: typeA,
                            isList: true,
                            isUnique: false,
                            isId: false,
                            idStrategy: null,
                            associatedSequence: null,
                            isCreatedAt: false,
                            isUpdatedAt: false,
                            isRequired: true,
                            isReadOnly: false,
                            comments: [],
                            directives: [],
                            defaultValue: null,
                            relatedField: relatedFieldForA,
                            databaseName: null,
                            relationName: this_1.normalizeRelatioName(type.name),
                        };
                        relatedFieldForA.relatedField = relatedFieldForB;
                        typeA.fields.push(relatedFieldForA);
                        typeB.fields.push(relatedFieldForB);
                    }
                    else {
                        // Self join to same field via join type.
                        var relatedField = {
                            name: typeA.name,
                            type: typeA,
                            isList: true,
                            isUnique: false,
                            isId: false,
                            idStrategy: null,
                            associatedSequence: null,
                            isCreatedAt: false,
                            isUpdatedAt: false,
                            isRequired: true,
                            isReadOnly: false,
                            comments: [],
                            directives: [],
                            defaultValue: null,
                            relatedField: null,
                            databaseName: null,
                            relationName: this_1.normalizeRelatioName(type.name),
                        };
                        typeA.fields.push(relatedField);
                    }
                    typeA.fields = typeA.fields.filter(function (x) { return x.type !== type; });
                    typeB.fields = typeB.fields.filter(function (x) { return x.type !== type; });
                }
                else {
                    // Not a prisma link type. Mark as link table.
                    type.isRelationTable = true;
                    // Drop ids. Compound PK indices are not supported yet.
                    relA.isId = false;
                    relB.isId = false;
                    nonJoinTypes.push(type);
                }
            }
            else {
                nonJoinTypes.push(type);
            }
        };
        var this_1 = this;
        try {
            for (var types_7 = __values(types), types_7_1 = types_7.next(); !types_7_1.done; types_7_1 = types_7.next()) {
                var type = types_7_1.value;
                _loop_3(type);
            }
        }
        catch (e_14_1) { e_14 = { error: e_14_1 }; }
        finally {
            try {
                if (types_7_1 && !types_7_1.done && (_a = types_7.return)) _a.call(types_7);
            }
            finally { if (e_14) throw e_14.error; }
        }
        return nonJoinTypes;
    };
    /**
     * Hides indices on related fields. These are always autmatically created by
     * prisma and dont need to be shown in the datamodel.
     * @param types
     */
    RelationalIntrospectionResult.prototype.hideIndicesOnRelatedFields = function (types) {
        var e_15, _a;
        try {
            for (var types_8 = __values(types), types_8_1 = types_8.next(); !types_8_1.done; types_8_1 = types_8.next()) {
                var type = types_8_1.value;
                // Keep indices which have not exactly one field, or if they have one field,
                // the field is a scalar field.
                type.indices = type.indices.filter(function (index) {
                    return index.fields.length !== 1 || typeof index.fields[0].type === 'string';
                });
            }
        }
        catch (e_15_1) { e_15 = { error: e_15_1 }; }
        finally {
            try {
                if (types_8_1 && !types_8_1.done && (_a = types_8.return)) _a.call(types_8);
            }
            finally { if (e_15) throw e_15.error; }
        }
        return types;
    };
    /**
     * Hides unique inidices and marks the corresponding fields as unique instead.
     * @param types
     */
    RelationalIntrospectionResult.prototype.hideUniqueIndices = function (types) {
        var e_16, _a, e_17, _b;
        try {
            for (var types_9 = __values(types), types_9_1 = types_9.next(); !types_9_1.done; types_9_1 = types_9.next()) {
                var type = types_9_1.value;
                var uniqueIndices = type.indices.filter(function (index) { return index.fields.length === 1 && index.unique; });
                var _loop_4 = function (uniqueIndex) {
                    uniqueIndex.fields[0].isUnique = true;
                    type.indices = type.indices.filter(function (x) { return x !== uniqueIndex; });
                };
                try {
                    for (var uniqueIndices_1 = __values(uniqueIndices), uniqueIndices_1_1 = uniqueIndices_1.next(); !uniqueIndices_1_1.done; uniqueIndices_1_1 = uniqueIndices_1.next()) {
                        var uniqueIndex = uniqueIndices_1_1.value;
                        _loop_4(uniqueIndex);
                    }
                }
                catch (e_17_1) { e_17 = { error: e_17_1 }; }
                finally {
                    try {
                        if (uniqueIndices_1_1 && !uniqueIndices_1_1.done && (_b = uniqueIndices_1.return)) _b.call(uniqueIndices_1);
                    }
                    finally { if (e_17) throw e_17.error; }
                }
            }
        }
        catch (e_16_1) { e_16 = { error: e_16_1 }; }
        finally {
            try {
                if (types_9_1 && !types_9_1.done && (_a = types_9.return)) _a.call(types_9);
            }
            finally { if (e_16) throw e_16.error; }
        }
        return types;
    };
    RelationalIntrospectionResult.prototype.hideReservedTypes = function (types) {
        var _this = this;
        return types.filter(function (x) { return !_this.isTypeReserved(x); });
    };
    RelationalIntrospectionResult.prototype.infer = function (model, enums, relations, sequences) {
        var _this = this;
        log("Datamodel inferrence started.");
        // TODO: Maybe we want to have a concept of hidden, which just skips rendering?
        // Ask tim, this is an important descision for the SDK
        var types = __spread(model.map(function (x) { return _this.inferObjectType(x); }), enums.map(function (x) { return _this.inferEnumType(x); }));
        log("Basic types inferred.");
        types = this.hideUniqueIndices(types);
        types = this.resolveSequences(types, sequences);
        types = this.resolveFallbackIdField(types); // unique flags and index types are required for this step.
        log("Id fields resolved.");
        types = this.inferDefaultValues(types);
        log("Default values inferred.");
        types = this.resolveRelations(types, relations);
        log("Relations resolved.");
        types = this.resolveEnumTypes(types);
        log("Relations enums resolved.");
        types = this.hideJoinTypes(types);
        types = this.hideReservedTypes(types);
        types = this.hideScalarListTypes(types);
        types = this.hideIndicesOnRelatedFields(types);
        types = this.hideJoinTypes(types);
        log("Extra artifacts hidden.");
        types = this.markNonIdFieldsWithSequencesAsErrored(types);
        types = this.markMultiIdFieldsForJoinTabesAsErrors(types);
        log("Validation done.");
        log("Normalization done.");
        return {
            comments: [],
            types: types,
        };
    };
    RelationalIntrospectionResult.prototype.inferIndex = function (index, fields) {
        var fieldCandidates = fields.filter(function (field) {
            return index.fields.filter(function (indexField) { return field.name === indexField; }).length > 0;
        });
        return {
            fields: fieldCandidates,
            name: index.name,
            unique: index.unique,
        };
    };
    // We need info about indices for resolving the exact type, as String is mapped to ID.
    // Also, we need info about the actual type before we resolve default values.
    RelationalIntrospectionResult.prototype.inferDefaultValues = function (types) {
        var e_18, _a, e_19, _b;
        try {
            for (var types_10 = __values(types), types_10_1 = types_10.next(); !types_10_1.done; types_10_1 = types_10.next()) {
                var type = types_10_1.value;
                try {
                    for (var _c = __values(type.fields), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var field = _d.value;
                        this.inferFieldTypeAndDefaultValue(field, type.name);
                    }
                }
                catch (e_19_1) { e_19 = { error: e_19_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_19) throw e_19.error; }
                }
            }
        }
        catch (e_18_1) { e_18 = { error: e_18_1 }; }
        finally {
            try {
                if (types_10_1 && !types_10_1.done && (_a = types_10.return)) _a.call(types_10);
            }
            finally { if (e_18) throw e_18.error; }
        }
        return types;
    };
    RelationalIntrospectionResult.prototype.inferEnumType = function (model) {
        var values = model.values.map(function (x) { return ({
            name: x,
            isCreatedAt: false,
            isId: false,
            idStrategy: null,
            associatedSequence: null,
            isList: false,
            isReadOnly: false,
            isRequired: false,
            isUnique: false,
            isUpdatedAt: false,
            relatedField: null,
            relationName: null,
            type: prisma_datamodel_1.TypeIdentifiers.string,
            defaultValue: null,
            databaseName: null,
            directives: [],
            comments: [],
        }); });
        return {
            name: model.name,
            fields: values,
            isEnum: true,
            isEmbedded: false,
            isRelationTable: false,
            databaseName: null,
            comments: [],
            directives: [],
            indices: [],
        };
    };
    RelationalIntrospectionResult.prototype.inferObjectType = function (model) {
        var _this = this;
        var e_20, _a;
        var fields = model.columns.map(function (x) { return _this.inferField(x); });
        var indices = model.indices.map(function (x) { return _this.inferIndex(x, fields); });
        // Resolve primary key
        if (model.primaryKey !== null) {
            var pk_1 = model.primaryKey;
            if (pk_1.fields.length === 1) {
                // Single PK field - prisma can do that
                var _b = __read(fields.filter(function (field) { return field.name === pk_1.fields[0]; }), 1), pkField = _b[0];
                if (!pkField) {
                    prisma_datamodel_1.GQLAssert.raise("Index/Schema missmatch during introspection. Field " + pk_1.fields[0] + " used in index, but does not exist on table " + model.name);
                }
                pkField.isId = true;
                pkField.idStrategy = prisma_datamodel_1.IdStrategy.Auto;
            }
            else {
                var _loop_5 = function (pkFieldName) {
                    var _a = __read(fields.filter(function (field) { return field.name === pkFieldName; }), 1), pkField = _a[0];
                    if (!pkField) {
                        prisma_datamodel_1.GQLAssert.raise("Index/Schema missmatch during introspection. Field " + pk_1.fields[0] + " used in index, but does not exist on table " + model.name);
                    }
                    pkField.isId = true;
                    pkField.idStrategy = prisma_datamodel_1.IdStrategy.Auto;
                };
                try {
                    // Compound PK - that's not supported, except for join tables
                    // We will mark it as error later.
                    for (var _c = __values(pk_1.fields), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var pkFieldName = _d.value;
                        _loop_5(pkFieldName);
                    }
                }
                catch (e_20_1) { e_20 = { error: e_20_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_20) throw e_20.error; }
                }
            }
        }
        return {
            name: model.name,
            isEmbedded: false,
            isEnum: false,
            isRelationTable: false,
            fields: fields,
            indices: indices,
            directives: [],
            comments: [],
            databaseName: null,
        };
    };
    RelationalIntrospectionResult.prototype.inferField = function (field) {
        var comments = [];
        if (field.comment !== null) {
            comments.push({
                text: field.comment,
                isError: false,
            });
        }
        var gqlField = {
            name: field.name,
            isUnique: field.isUnique,
            isRequired: !field.isNullable,
            defaultValue: field.defaultValue,
            isList: field.isList,
            type: field.type,
            isId: false,
            idStrategy: null,
            associatedSequence: null,
            relatedField: null,
            relationName: null,
            isCreatedAt: prisma_datamodel_1.LegacyRelationalReservedFields.createdAtFieldName === field.name,
            isUpdatedAt: prisma_datamodel_1.LegacyRelationalReservedFields.updatedAtFieldName === field.name,
            isReadOnly: false,
            comments: comments,
            directives: [],
            databaseName: null,
        };
        return gqlField;
    };
    RelationalIntrospectionResult.prototype.inferFieldTypeAndDefaultValue = function (field, typeName) {
        prisma_datamodel_1.GQLAssert.raiseIf(typeof field.type !== 'string', 'Must be called before resolving relations');
        var type = this.toTypeIdentifyer(field.type, field, typeName);
        if (type === null) {
            field.comments.push({
                text: "Type " + field.type + " is not supported",
                isError: true,
            });
            // Keep native type and register an error.
        }
        else {
            field.type = type;
        }
        if (field.defaultValue !== null) {
            prisma_datamodel_1.GQLAssert.raiseIf(typeof field.defaultValue !== 'string', 'Must be called with unparsed default values.');
            field.defaultValue = this.parseDefaultValue(field.defaultValue, field.type);
        }
    };
    return RelationalIntrospectionResult;
}(introspectionResult_1.IntrospectionResult));
exports.RelationalIntrospectionResult = RelationalIntrospectionResult;
//# sourceMappingURL=relationalIntrospectionResult.js.map